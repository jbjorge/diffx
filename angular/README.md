<!-- autogenerated by generate-readme.ts, do not edit -->
# @diffx/angular <!-- replaceLine:Diffx -->

## Introduction

Diffx is a state management library that focuses on minimizing boilerplate, effortless usage with typescript as well as
support for:

* [React](https://reactjs.org/) --> [@diffx/react](https://www.npmjs.com/package/@diffx/react)
* [Vue.js](https://vuejs.org/) --> [@diffx/vue](https://www.npmjs.com/package/@diffx/vue)
* [Angular](https://angular.io/) --> [@diffx/angular](https://www.npmjs.com/package/@diffx/angular)
* [RxJS](https://rxjs.dev/) --> [@diffx/rxjs](https://www.npmjs.com/package/@diffx/rxjs)

Debugging can be done with
the [devtools extension for Google Chrome](https://chrome.google.com/webstore/detail/diffx-devtools/ecijpnkbdaghilfokgbcieakdfbibeec).

## Fix angular change detection and the `async` pipe <!-- prependSection:Usage -->

Angular has the concept of code running inside zones, and anything running outside a zone will not trigger change
detection.

To ensure observables returned from Diffx are run in the correct zone, import zone-patch-rxjs in your `polyfills.ts`
file after your import of `zone`.

```typescript
import 'zone.js/dist/zone';
import 'zone.js/dist/zone-patch-rxjs'; // <--- This thing right here
```


## Usage

### `setDiffxOptions`

`setDiffxOptions(options)` is used to enable communication with the devtools extension.

```javascript
import { setDiffxOptions } from '@diffx/angular';

setDiffxOptions({
	debug: false / {
		/** Enable viewing the state history in devtools. Not recommended for use in a production environment. */
		devtools: true / false,
		/** Beware, creating stack traces for each state change is a slow operation. Not recommended for use in a production environment. */
		includeStackTrace: true / false
	}
})
```

### `createState`

`createState(namespace, state)` is used to create state in diffx and returns a copy of the state which diffx will watch for changes.

* `namespace` - a string which is used as the key when storing the state in the state tree. _The namespace has to be
  unique_.
* `state` - an object which contains the initial state

```javascript
import { createState } from '@diffx/angular';

export const coolnessFactor = createState('coolnessFactor', { numberOfCoolPeople: 1 });
export const people = createState('people', { names: ['Ola Nordmann'] });
```

### `setState`

`setState(reason, mutatorFunc)` is used to make changes to the state.

* `reason` - a string which explains why the state was changed. Will be displayed in the devtools extension for easier
  debugging.
* `mutatorFunc` - a function that wraps all changes to the state.

_Any changes made to the state outside of `setState` will throw an error._

```javascript
import { setState } from '@diffx/angular';
import { coolnessFactor, people } from './the-above-example';

setState('Adding myself to the list', () => {
	people.names.push('Kari Nordmann');
	coolnessFactor.numberOfCoolPeople++;
});
```

### `watchState` <!-- replaceSection:`watchState` -->

`watchState(stateGetter, options)` is used for creating an observable of the state or a projection of the state.

* `stateGetter` - a function which returns the state to be watched
* `options` - options object which describes how to watch the state

```javascript
import { watchState } from '@diffx/angular';
import { coolnessFactor, people } from './the-above-example';

const observable = watchState(() => people, {
	/**
	 * [Optional]
	 * Whether to emit the current value of the watched item(s).
	 *
	 * Default: false
	 */
	lazy: false,

	/**
	 * [Optional]
	 * Whether to emit each change to the state during `.setState` or
	 * to only emit the final state after the `.setState` function has finished running.
	 *
	 * Default: false
	 */
	emitIntermediateChanges: false,

	/**
	 * [Optional]
	 * Custom comparer function to decide if the state has changed.
	 * Receives newValue and oldValue as arguments and should return `true` for changed
	 * and `false` for no change.
	 *
	 * Default: Diffx does automatic change comparison
	 */
	hasChangedComparer: (newValue, oldValue) => 'true or false'
});

// stop watching
observable.unsubscribe();
```

### `destroyState`

`destroyState(namespace)` is used for removing state from diffx.

* `namespace` - the namespace (string) to destroy

_Any watchers of the destroyed state will **not** be automatically unwatched_.

### `@UseWatchers` <!-- append:Usage -->

`@UseWatchers(...watcher)` is used to automatically subscribe to a watcher when a component is instantiated. Accepts one
or more watchers as argument.

* `watcher` - an observable created with `watchState`.

This should only be used for watchers that should be started when a component is created, but not stopped when it is
destroyed. **Due to limitations in angular**, there is no way for the decorator to know when a component is destroyed or
to hook into lifecycle events.

Given the example state:

```typescript
// example-state.ts
import { createState } from '@diffx/angular';

export const state1 = createState('state1', {
	currentTime: Date.now(),
	timerRunning: false
});
```

And the example watcher:

```typescript
// example-watcher.ts
import { state1 } from '../example-state.ts';
import { share } from 'rxjs/operators';
import { setState, watchState } from '@diffx/angular';

let interval;

export default watchState(() => state1.timerRunning, { lazy: true })
	.pipe(
		tap(timerRunning => {
			if (timerRunning) {
				startTimer();
			} else {
				clearInterval(interval);
			}
		}),
		// it's a good idea to use share() to avoid multiple subscriptions
		// in case multiple components use the same watcher
		share()
	);

function startTimer(): void {
	interval = setInterval(() => {
		setState('Watcher: Update time', () => {
			state1.currentTime = Date.now();
		});
	}, 1000);
}
```

It can be used in a component like so:

```typescript
// example.component.ts
import { Component } from '@angular/core';
import { setState, watchState } from '@diffx/angular';
import { UseWatchers } from '@diffx/angular';
import { state1 } from '../example-state';
import timeWatcher from '../example-watcher.ts';

@UseWatchers(timeWatcher) // <-- this thing right here
@Component({
	selector: 'app-example',
	templateUrl: './example.component.html'
})
export class ExampleComponent {
	time$ = watchState(() => state1.currentTime);

	btnClick() {
		setState('User toggled timer', () => {
			state1.timerRunning = !state1.timerRunning;
		})
	}
}
```

## Typescript
Diffx is written in typescript and leans on typescript's type inference to avoid interface boilerplate.

## Credits and thanks

Thanks to the team behind [Vue.js](https://vuejs.org/) for making a great framework and the `@vue/reactive` package this
project depends on.  
Thanks to Benjamine, the creator of [jsondiffpatch](https://github.com/benjamine/jsondiffpatch) which this project uses
for creating diffs.  
Thanks to [Redux](https://redux.js.org/) for inspiring me to try my hand at decreasing boilerplate.
